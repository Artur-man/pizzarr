% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/array.R
\docType{class}
\name{Array}
\alias{Array}
\title{Array Class}
\description{
Instantiate an array from an initialized store.
Reference: https://github.com/zarr-developers/zarr-python/blob/5dd4a0/zarr/core.py#L51
}
\details{
The Zarr Array class.
}
\keyword{internal}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{store}}{Array store, already initialized.}

\item{\code{chunk_store}}{Separate storage for chunks. If not provided, \code{store} will be used for storage of both chunks and metadata.}

\item{\code{path}}{Storage path. String, optional.}

\item{\code{read_only}}{True if array should be protected against modification.}

\item{\code{synchronizer}}{Array synchronizer. Object, optional.}

\item{\code{cache_metadata}}{If True (default), array configuration metadata will be cached. If False, metadata will be reloaded prior to all data access and modification.}

\item{\code{cache_attrs}}{If True (default), user attributes will be cached. If False, attributes will be reloaded prior to all data access and modification.}

\item{\code{write_empty_chunks}}{If True, all chunks will be stored regardless of their contents. If False (default), each chunk is compared to the array's fill value prior to storing. If a chunk is uniformly equal to the fill value, then that chunk is not be stored, and the store entry for that chunk's key is deleted.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{Array$new()}}
\item \href{#method-get_shape}{\code{Array$get_shape()}}
\item \href{#method-clone}{\code{Array$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Get an item from the store.


Create a new Array instance.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Array$new(
  store,
  path = NA,
  read_only = FALSE,
  chunk_store = NA,
  synchronizer = NA,
  cache_metadata = TRUE,
  cache_attrs = TRUE,
  write_empty_chunks = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{store}}{Array store, already initialized.}

\item{\code{key}}{The item key.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The item data in a vector of type raw.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_shape"></a>}}
\if{latex}{\out{\hypertarget{method-get_shape}{}}}
\subsection{Method \code{get_shape()}}{
Get the array shape.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Array$get_shape()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
The shape metadata value.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Array$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
